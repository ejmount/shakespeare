use std::fmt::Debug;
use std::sync::Arc;
use std::task::{Context, Poll};

use futures::Future;
use tokio::task::JoinHandle;

#[non_exhaustive]
/// Indicates whether an actor closed down successfully and any output value produced
pub enum Outcome<A: Shell> {
	#[doc(hidden)]
	/// The actor was explicitly aborted.
	/// It shouldn't be possible to encounter this is in practice,
	Aborted(tokio::task::JoinError),
	/// The actor exited successfully when all of its strong references dropped
	Exit(A::ExitType),
	/// The actor panicked executing one of its message handlers.
	Panic(A::PanicType),
}

impl<A: Shell> Debug for Outcome<A> {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Outcome::Aborted(_) => f.write_str("ActorOutcome::Aborted"),
			Outcome::Exit(_) => f.write_str("ActorOutcome::Exit"),
			Outcome::Panic(_) => f.write_str("ActorOutcome::Panic"),
		}
	}
}

impl<A: Shell> PartialEq for Outcome<A>
where
	A::ExitType: PartialEq,
	A::PanicType: PartialEq,
{
	fn eq(&self, other: &Self) -> bool {
		use Outcome::{Exit, Panic};
		match (self, other) {
			(Exit(a), Exit(b)) => a == b,
			(Panic(a), Panic(b)) => a == b,
			_ => false,
		}
	}
}

impl<A: Shell> Eq for Outcome<A>
where
	A::ExitType: Eq,
	A::PanicType: Eq,
{
}

/// A handle for the actor's exit value.
///
/// Serves the same role as [`std::thread::JoinHandle`], but for an actor. Can be awaited to receive the actor's output value.
/// As with `JoinHandle`, dropping this value without awaiting it detaches the actor task and makes any output value from the actor inaccessible.
pub struct Handle<A: Shell>(JoinHandle<Result<A::ExitType, A::PanicType>>);

impl<A: Shell> Handle<A> {
	fn new(val: JoinHandle<Result<A::ExitType, A::PanicType>>) -> Handle<A> {
		Handle(val)
	}
}

impl<A: Shell> Debug for Handle<A> {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_str("ActorHandle")
	}
}

impl<A: Shell> Future for Handle<A> {
	type Output = Outcome<A>;

	fn poll(self: std::pin::Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
		let handle = &mut self.get_mut().0;
		tokio::pin!(handle);
		match handle.poll(cx) {
			Poll::Pending => Poll::Pending,
			Poll::Ready(result) => match result {
				Ok(Ok(e)) => Outcome::Exit(e),
				Ok(Err(f)) => Outcome::Panic(f),
				Err(e) => Outcome::Aborted(e),
			}
			.into(),
		}
	}
}

/// A trait indicating the message-handling external interface of an actor. Implementations will be generated by macros - you should not implement this manually.
pub trait Shell {
	/// The internal state type within this shell
	type StateType: State<ShellType = Self>;
	/// The output type yielded by the actor exiting successfully
	type ExitType;
	/// The output type yielded by the actor's panic handler after a message handler panicked
	type PanicType;
}

/// The state type of an actor. This is for macro use only.
pub trait State {
	/// The internal state type within this shell
	type ShellType: Shell<StateType = Self>;
}

/// Various values used to interact with an actor that has just been `start()`d.
///
/// The most important value here is the `Arc<A>`, which is the handle needed to send messages to the actor. This is ref-counted, and the actor will begin the process of shutting down when the last handle drops.
///
/// The `Handle<A>` is a future that enables awaiting on the actor's completion and retrieving its output value, either as a result of the last `Arc<A>` dropping or theh actor's message handlers panicking. However, if you do not need this value, the `Handle` can be discarded and the actor will continue running.
#[non_exhaustive]
#[derive(Debug)]
pub struct Spawn<A>
where
	A: Shell,
{
	/// A handle for sending messages to the actor
	pub msg_handle:  Arc<A>,
	/// A future for awaiting the actor's completion
	pub join_handle: Handle<A>,
}

impl<A: Shell> Spawn<A> {
	#[doc(hidden)]
	pub fn new(actor: Arc<A>, handle: JoinHandle<Result<A::ExitType, A::PanicType>>) -> Spawn<A> {
		Spawn {
			msg_handle:  actor,
			join_handle: Handle::new(handle),
		}
	}
}
