use std::fmt::Debug;
use std::sync::Arc;
use std::task::{Context, Poll};

use futures::Future;
use tokio::task::JoinHandle;

/// Indicates whether an actor closed down successfully and any output value produced
pub enum Outcome<A: Shell> {
	/// The actor exited successfully either as all of its strong references dropped or by explicit shutdown.
	Exit(A::ExitType),
	/// The actor panicked executing one of its message handlers.
	Panic(A::PanicType),
}

impl<A: Shell> Debug for Outcome<A> {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Outcome::Exit(_) => f.write_str("ActorOutcome::Exit"),
			Outcome::Panic(_) => f.write_str("ActorOutcome::Panic"),
		}
	}
}

impl<A: Shell> PartialEq for Outcome<A>
where
	A::ExitType: PartialEq,
	A::PanicType: PartialEq,
{
	fn eq(&self, other: &Self) -> bool {
		use Outcome::{Exit, Panic};
		match (self, other) {
			(Exit(a), Exit(b)) => a == b,
			(Panic(a), Panic(b)) => a == b,
			_ => false,
		}
	}
}

impl<A: Shell> Eq for Outcome<A>
where
	A::ExitType: Eq,
	A::PanicType: Eq,
{
}

/// A handle for the actor's exit value.
///
/// Serves the same role as [`std::thread::JoinHandle`], but for an actor. Can be awaited to receive the actor's output value.
/// As with `JoinHandle`, dropping this value without awaiting it detaches the actor task and makes any output value from the actor inaccessible, but does **not** shut down the actor's processing.
///
/// The exact types contained in the [`Outcome`] returned by the handle depends on whether the actor defines `stop` and/or a `catch` hook functions. (See the [actor macro](`crate::actor`) documentation.) If `stop` is defined, the `Exit` branch contains the same type as that function returns; if that function is not defined, it contains `()`. The same applies for `catch` and the `Panic` branch, except that if `catch` is not defined, the type is instead `Box<dyn std::any::Any + Send>`.
pub struct ExitHandle<A: Shell>(JoinHandle<Result<A::ExitType, A::PanicType>>);

impl<A: Shell> ExitHandle<A> {
	fn new(val: JoinHandle<Result<A::ExitType, A::PanicType>>) -> ExitHandle<A> {
		ExitHandle(val)
	}
}

impl<A: Shell> Debug for ExitHandle<A> {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_str("ExitHandle")
	}
}

impl<A: Shell> Future for ExitHandle<A> {
	type Output = Outcome<A>;

	fn poll(self: std::pin::Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
		let handle = &mut self.get_mut().0;
		tokio::pin!(handle);
		match handle.poll(cx) {
			Poll::Pending => Poll::Pending,
			Poll::Ready(result) => match result {
				Ok(Ok(e)) => Outcome::Exit(e),
				Ok(Err(f)) => Outcome::Panic(f),
				Err(e) => unreachable!(
					"Task for actor {} aborted with error {e} - this is a bug",
					std::any::type_name::<A>()
				),
			}
			.into(),
		}
	}
}

/// A trait indicating the message-handling external interface of an actor. Implementations will be generated by macros - you should not implement this manually.
pub trait Shell {
	/// The internal state type within this shell
	type StateType: State<ShellType = Self>;
	/// The output type yielded by the actor exiting successfully
	type ExitType;
	/// The output type yielded by the actor's panic handler after a message handler panicked
	type PanicType;
}

/// The state type of an actor. This trait is for macro use only.
pub trait State {
	/// The internal state type within this shell
	type ShellType: Shell<StateType = Self>;
}

/// Various values used to interact with an actor that has just been `start()`d.
///
/// The most important value here is the `Arc<A>`, which is the handle needed to send messages to the actor. This is ref-counted, and the actor will begin the process of shutting down when the last handle drops.
///
/// The `Handle<A>` is a future that enables awaiting on the actor's completion and retrieving its output value, either as a result of the last `Arc<A>` dropping or the actor's message handlers panicking. However, if you do not need this value, the `Handle` can be discarded and the actor will continue running.
#[non_exhaustive]
#[derive(Debug)]
pub struct ActorHandles<A>
where
	A: Shell,
{
	/// A handle for sending messages to the actor
	pub message_handle: Arc<A>,
	/// A future for awaiting the actor's completion
	pub join_handle:    ExitHandle<A>,
}

impl<A: Shell> ActorHandles<A> {
	#[doc(hidden)]
	pub fn new(
		actor: Arc<A>,
		handle: JoinHandle<Result<A::ExitType, A::PanicType>>,
	) -> ActorHandles<A> {
		ActorHandles {
			message_handle: actor,
			join_handle:    ExitHandle::new(handle),
		}
	}
}
